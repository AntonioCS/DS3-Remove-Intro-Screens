#include <Windows.h>
#include <MinHook.h>
#include <unknwn.h> //LPUNKNOWN
#include <algorithm> //std::transform
#include <string>
#include <vector>
#include <cstdint> // uint8_t

/*
#if _WIN32 || _WIN64
#if _WIN64
#pragma comment(lib, "libMinHook.x64.lib")
#else
#pragma comment(lib, "libMinHook.x86.lib")
#endif
#endif
*/

struct Patch {
	DWORD64 relAddr;
	DWORD size;
	uint8_t patch[50];
	uint8_t orig[50];
};

const std::vector<Patch> Patches_DS1{
	//Latest
	Patch{ 0x8320B0, 7, { 0xE9, 0x27, 0x01, 0x00, 0x00, 0x90, 0x90},{ 0xFF, 0x24, 0x85, 0x24, 0x22, 0xC3, 0x00} },
	Patch{ 0x8322B3, 2, { 0x90, 0x90}, { 0x74, 0x0D} },
	//Debug build
	Patch{ 0x831B30, 7, { 0xE9, 0x27, 0x01, 0x00, 0x00, 0x90, 0x90},{ 0xFF, 0x24, 0x85, 0xA4, 0x1C, 0xC3, 0x00} },
	Patch{ 0x831D33, 2, { 0x90, 0x90},{ 0x74, 0x0D} }
};

const std::vector<Patch> Patches_DS3{
	//v1.8
	Patch{ 0x0BD6ACF, 20, { 0x48, 0x31, 0xC0, 0x48, 0x89, 0x02, 0x49, 0x89, 0x04, 0x24, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90},{ 0xE8, 0xAC, 0xC6, 0xFB, 0xFF, 0x90, 0x4D, 0x8B, 0xC7, 0x49, 0x8B, 0xD4, 0x48, 0x8B, 0xC8, 0xE8, 0x9D, 0xC6, 0xFB, 0xFF} },
	//v1.4
	Patch{ 0x0BBB0CF, 20, { 0x48, 0x31, 0xC0, 0x48, 0x89, 0x02, 0x49, 0x89, 0x04, 0x24, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90},{ 0xE8, 0x8C, 0x07, 0xFC, 0xFF, 0x90, 0x4D, 0x8B, 0xC7, 0x49, 0x8B, 0xD4, 0x48, 0x8B, 0xC8, 0xE8, 0x7D, 0x07, 0xFC, 0xFF} },
	//v1.12
	Patch{ 0x0BE7D9F, 20, { 0x48, 0x31, 0xC0, 0x48, 0x89, 0x02, 0x49, 0x89, 0x04, 0x24, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90},{ 0xE8, 0x0C, 0xBA, 0xFB, 0xFF, 0x90, 0x4D, 0x8B, 0xC7, 0x49, 0x8B, 0xD4, 0x48, 0x8B, 0xC8, 0xE8, 0xFD, 0xB9, 0xFB, 0xFF} },
	//v1.11
	Patch{ 0x0BE6F8F, 20, { 0x48, 0x31, 0xC0, 0x48, 0x89, 0x02, 0x49, 0x89, 0x04, 0x24, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90},{ 0xE8, 0x9C, 0xBD, 0xFB, 0xFF, 0x90, 0x4D, 0x8B, 0xC7, 0x49, 0x8B, 0xD4, 0x48, 0x8B, 0xC8, 0xE8, 0x8D, 0xBD, 0xFB, 0xFF} },
	//v1.10
	Patch{ 0x0BD70FF, 20, { 0x48, 0x31, 0xC0, 0x48, 0x89, 0x02, 0x49, 0x89, 0x04, 0x24, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90},{ 0xE8, 0xAC, 0xC6, 0xFB, 0xFF, 0x90, 0x4D, 0x8B, 0xC7, 0x49, 0x8B, 0xD4, 0x48, 0x8B, 0xC8, 0xE8, 0x9D, 0xC6, 0xFB, 0xFF} },
	//v1.9
	Patch{ 0x0BD708F, 20, { 0x48, 0x31, 0xC0, 0x48, 0x89, 0x02, 0x49, 0x89, 0x04, 0x24, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90},{ 0xE8, 0xAC, 0xC6, 0xFB, 0xFF, 0x90, 0x4D, 0x8B, 0xC7, 0x49, 0x8B, 0xD4, 0x48, 0x8B, 0xC8, 0xE8, 0x9D, 0xC6, 0xFB, 0xFF} },
	//1.13
	Patch{ 0x0BE993F, 20, { 0x48, 0x31, 0xC0, 0x48, 0x89, 0x02, 0x49, 0x89, 0x04, 0x24, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90},{ 0xE8, 0x1C, 0xBA, 0xFB, 0xFF, 0x90, 0x4D, 0x8B, 0xC7, 0x49, 0x8B, 0xD4, 0x48, 0x8B, 0xC8, 0xE8, 0x0D, 0xBA, 0xFB, 0xFF} },
	//1.14
	Patch{ 0x0BE9C0F, 20, { 0x48, 0x31, 0xC0, 0x48, 0x89, 0x02, 0x49, 0x89, 0x04, 0x24, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90},{ 0xE8, 0x1C, 0xBA, 0xFB, 0xFF, 0x90, 0x4D, 0x8B, 0xC7, 0x49, 0x8B, 0xD4, 0x48, 0x8B, 0xC8, 0xE8, 0x0D, 0xBA, 0xFB, 0xFF} },
	//1.15
	Patch{ 0x0BE9D0F, 20, { 0x48, 0x31, 0xC0, 0x48, 0x89, 0x02, 0x49, 0x89, 0x04, 0x24, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90},{ 0xE8, 0x1C, 0xBA, 0xFB, 0xFF, 0x90, 0x4D, 0x8B, 0xC7, 0x49, 0x8B, 0xD4, 0x48, 0x8B, 0xC8, 0xE8, 0x0D, 0xBA, 0xFB, 0xFF} },
};

const std::vector<Patch> Patches_Sekiro{
	//1.02
	Patch{ 0x0A78738, 36, { 0x48, 0x31, 0xd2, 0x48, 0x89, 0x55, 0x67, 0x48, 0x89, 0x55, 0x7F, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90}, { 0x48, 0x8D, 0x57, 0x30, 0x48, 0x85, 0xFF, 0x48, 0x0F, 0x44, 0xD6, 0x48, 0x8D, 0x4D, 0x7F, 0xE8, 0x34, 0x3A, 0x37, 0x00, 0x90, 0x4C, 0x8B, 0xC3, 0x48, 0x8D, 0x55, 0x67, 0x48, 0x8B, 0xC8, 0xE8, 0x04, 0xD5, 0x33, 0x00} },
	Patch{ 0x0A7B675, 33, { 0x48, 0x31, 0xd2, 0x48, 0x89, 0x94, 0x24, 0x98, 0x00, 0x00, 0x00, 0x48, 0x89, 0x54, 0x24, 0x20, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90}, { 0x48, 0x8B, 0xD7, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xE8, 0xFE, 0x0A, 0x37, 0x00, 0x90, 0x4C, 0x8B, 0xC3, 0x48, 0x8D, 0x94, 0x24, 0x98, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xC8, 0xE8, 0xCA, 0xA5, 0x33, 0x00} },
};


enum class GAME {
	DS1,
	DS3,
	SEKIRO,
	UNKNOWN
};

GAME Game{};
typedef DWORD64(__cdecl *STEAMINIT)();
STEAMINIT fpSteamInit = nullptr;

typedef DWORD64(__stdcall *DIRECTINPUT8CREATE)(HINSTANCE, DWORD, REFIID, LPVOID *, LPUNKNOWN);
DIRECTINPUT8CREATE fpDirectInput8Create = nullptr;

extern "C" __declspec(dllexport)  HRESULT __stdcall DirectInput8Create(
	HINSTANCE hinst,
	DWORD dwVersion,
	REFIID riidltf,
	LPVOID * ppvOut,
	LPUNKNOWN punkOuter
)
{
	return fpDirectInput8Create(hinst, dwVersion, riidltf, ppvOut, punkOuter);
}
//struct MatchPathSeparator
//{
//	bool operator()(char ch) const
//	{
//		return ch == '\\' || ch == '/';
//	}
//};

std::string basename(std::string const& pathname)
{
	static auto helper_func = [](char ch)
	{
		return ch == '\\' || ch == '/';
	};

	return std::string(
		std::find_if(
			pathname.rbegin(), 
			pathname.rend(),
			//MatchPathSeparator()).base(),
			helper_func).base(),
		pathname.end());
}

GAME DetermineGame() {
    char fnPtr[MAX_PATH];
    auto fnLen = GetModuleFileNameA(0, fnPtr, MAX_PATH);

    auto fileName = basename(std::string(fnPtr, fnLen));
    std::transform(fileName.begin(), fileName.end(), fileName.begin(), ::tolower);

    if (fileName == "darksouls.exe")	return GAME::DS1;	
    if (fileName == "darksoulsiii.exe") return GAME::DS3;	
    if (fileName == "sekiro.exe")		return GAME::SEKIRO;

    return GAME::UNKNOWN;
}

void ApplyPatches(const std::vector<Patch>&);

void ApplyDS1Patches() {
    ApplyPatches(Patches_DS1);
}

void ApplyDS3Patches() {
    ApplyPatches(Patches_DS3);
}

void ApplySekiroPatches() {
    ApplyPatches(Patches_Sekiro);
}


void ApplyPatches(const std::vector<Patch>& patches)
{
	const auto* baseAddr = GetModuleHandle(NULL);

    for (const auto& patch : patches) {
        auto* addr = (void*)((DWORD64)baseAddr + patch.relAddr);
        auto size = patch.size;

        if (memcmp(addr, patch.orig, size) == 0) {
            DWORD old;
            VirtualProtect(addr, size, PAGE_EXECUTE_READWRITE, &old);
            memcpy(addr, patch.patch, size);
            VirtualProtect(addr, size, old, &old);
            break;
        }
    }
}


DWORD64 __cdecl onSteamInit() {
    if (Game == GAME::DS3) {
        ApplyDS3Patches();
    }
    else if (Game == GAME::SEKIRO) {
        ApplySekiroPatches();
    }
    return fpSteamInit();
}


void SetupD8Proxy() {
	char syspath[MAX_PATH];
	GetSystemDirectoryA(syspath, MAX_PATH);
	strcat_s(syspath, "\\dinput8.dll");
	auto* hMod = LoadLibraryA(syspath);
	fpDirectInput8Create = (DIRECTINPUT8CREATE)GetProcAddress(hMod, "DirectInput8Create");
}

void AttachSteamHook() {
	auto* steamApiHwnd = GetModuleHandle(L"steam_api64.dll");
	auto initAddr = GetProcAddress(steamApiHwnd, "SteamAPI_Init");

	MH_CreateHook(initAddr, &onSteamInit, reinterpret_cast<LPVOID*>(&fpSteamInit));
	MH_EnableHook(initAddr);
}

BOOL APIENTRY DllMain(
	[[maybe_unused]]HMODULE hModule,
	DWORD  ul_reason_for_call,
	[[maybe_unused]]LPVOID lpReserved
)
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		Game = DetermineGame();
		if (Game == GAME::UNKNOWN) {
			MessageBoxA(0, "Unable to determine game. Valid EXEs are darksouls.exe, darksoulsiii.exe and sekiro.exe", "", 0);
			break;
		}

		MH_Initialize();
		SetupD8Proxy();
		if (Game == GAME::DS3 || Game == GAME::SEKIRO) {
			//These games are packed. Wait until steam init to apply the patches.
			AttachSteamHook();
		}
		if (Game == GAME::DS1) {
			ApplyDS1Patches();
		}
		break;
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
    default:
		break;
	}
	return TRUE;
}

